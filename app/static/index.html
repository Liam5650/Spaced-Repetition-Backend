<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Spaced Repetition Demo UI</title>

  <style>
    /* Structural / layout */
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; max-width: 1200px; }
    h2 { margin: 0 0 8px 0; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .box { border: 1px solid #ddd; padding: 12px; border-radius: 8px; margin: 12px 0; }
    input, select, button, textarea { padding: 8px; }
    textarea { width: 100%; min-height: 32px; box-sizing: border-box;}
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    @media (max-width: 800px) {.grid2 { grid-template-columns: 1fr; }}
    .cardsGrid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 10px; margin-top: 10px; }
    .cardsGrid {max-height: 300px; overflow-y: auto;}
    .hidden { display: none; }
    .cardBox { border: 1px solid #eee; border-radius: 8px; padding: 12px; background: #fafafa; }
    .cardBox {white-space: pre-wrap; overflow-wrap: anywhere;}
    #newFront + #newBack, #dueFront + #dueBack {margin-top: 8px;}
    .cardBox pre {margin: 0; min-height: 1.2em;}
    .cardActions {display: flex; gap: 8px; margin-top: 10px;}

    /* Status & semantic styling */
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 13px; }
    .muted { color: #666; font-size: 14px; }
    .error { color: #b00020; font-size: 14px; }
    .ok { color: #0b7a0b; font-size: 14px; }
  </style>

</head>

<body>

  <h1>Spaced Repetition Demo UI</h1>
  <div class="muted">Typical example flow: Signup → Login → Create deck → Create card under deck → Learn card → Review card</div>

  <!--Auth Actions-->
  <div class="box">
    <h2>Auth</h2>
    <div class="row">
      <input id="email" placeholder="email" value="demo@test.com" />
      <input id="password" type="password" placeholder="password" value="password123" />
      <button id="btnSignup">Signup</button>
      <button id="btnLogin">Login</button>
      <button id="btnLogout">Logout</button>
      <button id="btnDeleteMe">Delete account</button>
    </div>
    <div id="authStatus" class="muted">Not logged in.</div>
  </div>

  <!--Basic deck and card CRUD actions-->
  <div class="grid2">

    <!--Deck Section-->
    <div class="box">
      <h2>Decks</h2>
      <div class="row">
        <button id="btnLoadDecks">Load decks</button>
        <select id="deckSelect"></select>
        <span id="deckStatus" class="muted">No decks loaded.</span>
      </div>

      <div class="row" style="margin-top:10px;">
        <div class="mono">Current deck:</div>
        <div id="currentDeckLabel" class="mono muted">None selected</div>
      </div>

      <div class="row" style="margin-top:10px;">
        <input id="newDeckName" placeholder="New deck name" />
        <button id="btnCreateDeck">Create deck</button>
        <button id="btnDeleteDeck" class="smallBtn">Delete selected deck</button>
      </div>

      <div class="row" style="margin-top:10px;">
        <button id="btnShowDeckCards">Show cards in deck</button>
        <span id="deckCardsStatus" class="muted">No cards displayed.</span>
      </div>

      <div id="deckCards" class="cardsGrid"></div>
    </div>

    <!--Card Section-->
    <div class="box">
      <h2>Create card</h2>
      <div class="muted">Creates a card in the currently selected deck.</div>
      <div style="margin-top:10px;">
        <div class="muted">Front</div>
        <textarea id="cardFrontIn" placeholder="e.g. こんにちは"></textarea>
        <div class="muted" style="margin-top:8px;">Back</div>
        <textarea id="cardBackIn" placeholder="e.g. Hello"></textarea>
        <div class="row" style="margin-top:10px;">
          <button id="btnCreateCard">Create card</button>
          <span id="createCardStatus" class="muted"></span>
        </div>
      </div>
    </div>
  </div>

  <!--Learning and Reviewing Actions-->
  <div class="grid2">

    <!--Learning Section-->
    <div class="box">
      <div class="sectionTitle">
        <h2>Learn Cards</h2>
        <div class="muted">New → Learn → (becomes due)</div>
      </div>

      <div class="row">
        <button id="btnLoadNew">Load next new</button>
        <button id="btnRevealNewBack">Reveal back</button>
        <button id="btnLearnCurrent" class="hidden">Learn card</button>
      </div>

      <div style="margin-top:12px;">
        <div class="muted">Current NEW card:</div>
        <div id="newFront" class="cardBox"><pre class="card"></pre></div>
        <div id="newBack" class="cardBox hidden"><pre class="card"></pre></div>
        <div id="newMeta" class="muted mono">No card loaded</div>
      </div>
    </div>

    <!--Reviewing Section-->
    <div class="box">
      <div class="sectionTitle">
        <h2>Review Cards</h2>
        <div class="muted">Due → Review (confidence from 0–5, 3 or more is pass and 2 or less is fail)</div>
      </div>

      <div class="row">
        <button id="btnLoadDue">Load next due</button>
        <button id="btnRevealDueBack">Reveal back</button>
      </div>

      <div class="row hidden" id="reviewRow" style="margin-top:10px;">
        <span class="muted">Review:</span>
        <button class="btnReview" data-q="0">0</button>
        <button class="btnReview" data-q="1">1</button>
        <button class="btnReview" data-q="2">2</button>
        <button class="btnReview" data-q="3">3</button>
        <button class="btnReview" data-q="4">4</button>
        <button class="btnReview" data-q="5">5</button>
      </div>

      <div style="margin-top:12px;">
        <div class="muted">Current DUE card:</div>
        <div id="dueFront" class="cardBox"><pre class="card"></pre></div>
        <div id="dueBack" class="cardBox hidden"><pre class="card"></pre></div>
        <div id="dueMeta" class="muted mono">No card loaded</div>
      </div>
    </div>
  </div>

  <!--Scripts Section-->
  <script>

    // ESSENTIALS

    //Login state
    let token = null;

    //Auth headers
    function authHeaders() {
      if (!token) return {};
      return { Authorization: `Bearer ${token}` };
    }

    // AUTHORIZATION SCRIPTS

    //References
    const emailInput = document.getElementById("email");
    const passwordInput = document.getElementById("password");
    const signupBtn = document.getElementById("btnSignup");
    const authStatus = document.getElementById("authStatus");
    const loginBtn = document.getElementById("btnLogin");
    const logoutBtn = document.getElementById("btnLogout");
    const deleteMeBtn = document.getElementById("btnDeleteMe");

    //Signup
    signupBtn.addEventListener("click", async () => {
      const email = emailInput.value;
      const password = passwordInput.value;

      try {
        const res = await fetch("/signup", {method: "POST", headers: {"Content-Type": "application/json",},
          body: JSON.stringify({email: email, password: password,}),});

        if (!res.ok) {
          const err = await res.json();
          throw new Error(err.detail || "Signup failed");
        }
        const data = await res.json();
        authStatus.className = "ok";
        authStatus.textContent = `Signed up as ${data.email}`;
      } catch (err) {
        authStatus.className = "error";
        authStatus.textContent = err.message;
      }
    });

    //Login
    loginBtn.addEventListener("click", async () => {
      try {
        const res = await fetch("/login", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            email: emailInput.value,
            password: passwordInput.value,
          }),
        });

        if (!res.ok) throw new Error((await res.json()).detail || "Login failed");

        const data = await res.json();
        token = data.access_token;

        const meRes = await fetch("/me", { headers: authHeaders() });
        if (!meRes.ok) throw new Error("Token check failed");

        const me = await meRes.json();
        authStatus.className = "ok";
        authStatus.textContent = `Logged in. user_id=${me.user_id}`;
        await loadDecks();
      } catch (err) {
        token = null;
        authStatus.className = "error";
        authStatus.textContent = err.message;
      }
    });

    //Logout
    logoutBtn.addEventListener("click", () => {
      token = null;
      authStatus.className = "muted";
      authStatus.textContent = "Not logged in.";
      clearDeckUI();
    });

    //Delete Account
    deleteMeBtn.addEventListener("click", async () => {
      if (!token) {
        authStatus.className = "error";
        authStatus.textContent = "Login first.";
        return;
      }

      if (!confirm("Delete your account permanently? This cannot be undone.")) return;

      try {
        const res = await fetch("/users/me", {
          method: "DELETE",
          headers: { "Content-Type": "application/json", ...authHeaders() },
          body: JSON.stringify({ password: passwordInput.value }),
        });

        if (!res.ok) throw new Error((await res.json()).detail || "Delete failed");

        token = null;
        authStatus.className = "ok";
        authStatus.textContent = "Account deleted.";
        clearDeckUI();
      } catch (err) {
        authStatus.className = "error";
        authStatus.textContent = err.message;
      }
    });

    // DECK SCRIPTS

    //References
    const btnLoadDecks = document.getElementById("btnLoadDecks");
    const deckSelect = document.getElementById("deckSelect");
    const deckStatus = document.getElementById("deckStatus");
    const currentDeckLabel = document.getElementById("currentDeckLabel");
    const newDeckNameInput = document.getElementById("newDeckName");
    const btnCreateDeck = document.getElementById("btnCreateDeck");
    const btnDeleteDeck = document.getElementById("btnDeleteDeck");

    //Load Decks
    async function loadDecks() {
      if (!token) {
        deckStatus.className = "error";
        deckStatus.textContent = "Login first.";
        return;
      }

      deckStatus.className = "muted";
      deckStatus.textContent = "Loading decks...";

      const res = await fetch("/decks", { headers: authHeaders() });
      if (!res.ok) throw new Error((await res.json()).detail || "Failed to load decks");

      const decks = await res.json(); // list of { id, name }
      deckSelect.innerHTML = "";

      if (decks.length === 0) {
        clearDeckUI();
        return;
      }

      for (const d of decks) {
        const opt = document.createElement("option");
        opt.value = d.id;
        opt.textContent = d.name;
        deckSelect.appendChild(opt);
      }

      deckStatus.className = "ok";
      deckStatus.textContent = `Loaded ${decks.length} deck(s).`;

      // Set current deck label to selected one
      deckSelect.dispatchEvent(new Event("change"));
    }

    btnLoadDecks.addEventListener("click", async () => {
      try {
        await loadDecks();
      } catch (err) {
        deckStatus.className = "error";
        deckStatus.textContent = err.message;
      }
    });

    deckSelect.addEventListener("change", () => {
      currentDeckLabel.textContent = deckSelect.options[deckSelect.selectedIndex]?.textContent || "None selected";

      const label = currentDeckLabel.textContent;

      if (deckSelect.selectedIndex !== -1) {
        deckStatus.className = "ok";
        deckStatus.textContent = `Selected deck: ${label}`;
      } else {
        deckStatus.className = "muted";
        deckStatus.textContent = "No deck selected.";
      }

      // Clear card display when deck changes
      clearCardsUI();
      clearLearnUI();
      clearReviewUI();
    });
 
    //Create Deck
    btnCreateDeck.addEventListener("click", async () => {
      const name = newDeckNameInput.value.trim();

      if (!token) {
        deckStatus.className = "error";
        deckStatus.textContent = "Login first.";
        return;
      }
      if (!name) {
        deckStatus.className = "error";
        deckStatus.textContent = "Deck name is required.";
        return;
      }

      try {
        const res = await fetch("/decks", {
          method: "POST",
          headers: { "Content-Type": "application/json", ...authHeaders() },
          body: JSON.stringify({ name }),
        });

        if (!res.ok) throw new Error((await res.json()).detail || "Create deck failed");

        const created = await res.json(); // {id, name}
        deckStatus.className = "ok";
        deckStatus.textContent = `Created deck: ${created.name}`;

        newDeckNameInput.value = "";
        await loadDecks();

        // Select the newly created deck in the dropdown
        deckSelect.value = String(created.id);
        deckSelect.dispatchEvent(new Event("change"));
      } catch (err) {
        deckStatus.className = "error";
        deckStatus.textContent = err.message;
      }
    });

    //Delete Deck
    function selectedDeckId() {
      const v = deckSelect.value;
      return v ? Number(v) : null;
    }
 
    btnDeleteDeck.addEventListener("click", async () => {
      const deckId = selectedDeckId();

      if (!token) {
        deckStatus.className = "error";
        deckStatus.textContent = "Login first.";
        return;
      }
      if (!deckId) {
        deckStatus.className = "error";
        deckStatus.textContent = "Select a deck first.";
        return;
      }

      const deckName = deckSelect.options[deckSelect.selectedIndex]?.textContent || "this deck";

      if (!confirm(`Delete "${deckName}"? This will also delete its cards.`)) return;

      try {
        const res = await fetch(`/decks/${deckId}`, {
          method: "DELETE",
          headers: authHeaders(),
        });

        if (!res.ok) throw new Error((await res.json()).detail || "Delete deck failed");

        deckStatus.className = "ok";
        deckStatus.textContent = `Deleted deck "${deckName}".`;

        await loadDecks(); // refresh dropdown

      } catch (err) {
        deckStatus.className = "error";
        deckStatus.textContent = err.message;
      }
    });

    // CARD CRUD SCRIPTS

    //References
    const cardFrontIn = document.getElementById("cardFrontIn");
    const cardBackIn = document.getElementById("cardBackIn");
    const btnCreateCard = document.getElementById("btnCreateCard");
    const createCardStatus = document.getElementById("createCardStatus");
    const btnShowDeckCards = document.getElementById("btnShowDeckCards");
    const deckCardsStatus = document.getElementById("deckCardsStatus");
    const deckCards = document.getElementById("deckCards");

    //Create Card
    btnCreateCard.addEventListener("click", async () => {
      const deckId = selectedDeckId(); // Make sure to use selected deck
      const front = cardFrontIn.value.trim();
      const back = cardBackIn.value.trim();

      if (!token) {
        createCardStatus.className = "error";
        createCardStatus.textContent = "Login first.";
        return;
      }
      if (!deckId) {
        createCardStatus.className = "error";
        createCardStatus.textContent = "Select a deck first.";
        return;
      }
      if (!front || !back) {
        createCardStatus.className = "error";
        createCardStatus.textContent = "Front and back are required.";
        return;
      }

      try {
        const res = await fetch(`/decks/${deckId}/cards`, {
          method: "POST",
          headers: { "Content-Type": "application/json", ...authHeaders() },
          body: JSON.stringify({ front, back }),
        });

        if (!res.ok) throw new Error((await res.json()).detail || "Create card failed");

        const created = await res.json(); // {id, front, back}
        createCardStatus.className = "ok";
        const deckName = deckSelect.options[deckSelect.selectedIndex]?.textContent || "Unknown deck";
        createCardStatus.textContent = `Created card with id "${created.id}" in ${deckName}.`;

        // clear inputs
        cardFrontIn.value = "";
        cardBackIn.value = "";
      } catch (err) {
        createCardStatus.className = "error";
        createCardStatus.textContent = err.message;
      }
    });

    //Show cards in deck
    function renderCards(cards) {
      deckCards.innerHTML = "";

      for (const c of cards) {
        const box = document.createElement("div");
        box.className = "cardBox";

        const meta = document.createElement("div");
        meta.className = "mono muted";
        meta.textContent = `Card #${c.id}`;

        const front = document.createElement("div");
        front.style.marginTop = "6px";
        front.textContent = `Front: ${c.front}`;

        const back = document.createElement("div");
        back.style.marginTop = "6px";
        back.textContent = `Back: ${c.back}`;

        const actions = document.createElement("div");
        actions.className = "cardActions";

        const btnEdit = document.createElement("button");
        btnEdit.textContent = "Edit";
        btnEdit.addEventListener("click", () => {
          enterEditMode(box, c); // pass the card object
        });

        const btnDelete = document.createElement("button");
        btnDelete.textContent = "Delete";
        btnDelete.addEventListener("click", () => {
          deleteCard(c.id);
        });

        actions.appendChild(btnEdit);
        actions.appendChild(btnDelete);

        box.appendChild(meta);
        box.appendChild(front);
        box.appendChild(back);
        box.appendChild(actions);
        deckCards.appendChild(box);
      }
    }

    btnShowDeckCards.addEventListener("click", async () => {
      const deckId = selectedDeckId();

      if (!token) {
        deckCardsStatus.className = "error";
        deckCardsStatus.textContent = "Login first.";
        return;
      }
      if (!deckId) {
        deckCardsStatus.className = "error";
        deckCardsStatus.textContent = "Select a deck first.";
        return;
      }

      try {
        deckCardsStatus.className = "muted";
        deckCardsStatus.textContent = "Loading cards...";

        const res = await fetch(`/decks/${deckId}/cards`, {
          headers: authHeaders(),
        });

        if (!res.ok) throw new Error((await res.json()).detail || "Failed to load cards");

        const cards = await res.json(); // [{id, front, back}, ...]

        if (cards.length === 0) {
          deckCards.innerHTML = "";
          deckCardsStatus.className = "muted";
          deckCardsStatus.textContent = "No cards in this deck yet.";
          return;
        }

        renderCards(cards);
        deckCardsStatus.className = "ok";
        const deckName = deckSelect.options[deckSelect.selectedIndex]?.textContent || "Unknown deck";
        deckCardsStatus.textContent = `Showing ${cards.length} card(s) in deck "${deckName}".`;
      } catch (err) {
        deckCardsStatus.className = "error";
        deckCardsStatus.textContent = err.message;
      }
    });

    //Delete Card
    async function deleteCard(cardId) {
      if (!token) {
        deckCardsStatus.className = "error";
        deckCardsStatus.textContent = "Login first.";
        return;
      }

      if (!confirm(`Delete card ${cardId}?`)) return;

      try {
        const res = await fetch(`/cards/${cardId}`, {
          method: "DELETE",
          headers: authHeaders(),
        });

        if (!res.ok)
          throw new Error((await res.json()).detail || "Delete card failed");

        deckCardsStatus.className = "ok";
        deckCardsStatus.textContent = `Deleted card ${cardId}.`;

        // Reload cards for current deck
        const deckId = selectedDeckId();
        if (deckId) {
          const cardsRes = await fetch(`/decks/${deckId}/cards`, {
            headers: authHeaders(),
          });
          const cards = await cardsRes.json();
          renderCards(cards);
        }
      } catch (err) {
        deckCardsStatus.className = "error";
        deckCardsStatus.textContent = err.message;
      }
    }

    //Edit Card
    function enterEditMode(cardBoxEl, card) {
      // Prevent double-enter
      if (cardBoxEl.dataset.editing === "1") return;
      cardBoxEl.dataset.editing = "1";

      // Find existing nodes we created (meta, front, back, actions)
      const metaEl = cardBoxEl.querySelector(".mono.muted");
      const frontEl = metaEl.nextElementSibling; // front div
      const backEl = frontEl.nextElementSibling; // back div
      const actionsEl = backEl.nextElementSibling; // actions div

      // Save original display text in case user cancels
      const originalFront = card.front;
      const originalBack = card.back;

      // Create inputs
      const frontInput = document.createElement("textarea");
      frontInput.value = originalFront;

      const backInput = document.createElement("textarea");
      backInput.value = originalBack;

      // Replace front/back display with inputs
      frontEl.textContent = "Front:";
      frontEl.appendChild(document.createElement("br"));
      frontEl.appendChild(frontInput);

      backEl.textContent = "Back:";
      backEl.appendChild(document.createElement("br"));
      backEl.appendChild(backInput);

      // Replace actions with Save/Cancel
      actionsEl.innerHTML = "";

      const btnSave = document.createElement("button");
      btnSave.textContent = "Save";
      btnSave.addEventListener("click", async () => {
        await saveCardEdits(cardBoxEl, card, frontInput.value, backInput.value);
      });

      const btnCancel = document.createElement("button");
      btnCancel.textContent = "Cancel";
      btnCancel.addEventListener("click", () => {
        exitEditMode(cardBoxEl, card);
      });

      actionsEl.appendChild(btnSave);
      actionsEl.appendChild(btnCancel);

      frontInput.focus();
    }

    function exitEditMode(cardBoxEl, card) {
      cardBoxEl.dataset.editing = "0";

      const metaEl = cardBoxEl.querySelector(".mono.muted");
      const frontEl = metaEl.nextElementSibling;
      const backEl = frontEl.nextElementSibling;
      const actionsEl = backEl.nextElementSibling;

      // Restore view text
      frontEl.textContent = `Front: ${card.front}`;
      backEl.textContent = `Back: ${card.back}`;

      // Restore Edit/Delete buttons
      actionsEl.innerHTML = "";

      const btnEdit = document.createElement("button");
      btnEdit.textContent = "Edit";
      btnEdit.addEventListener("click", () => enterEditMode(cardBoxEl, card));

      const btnDelete = document.createElement("button");
      btnDelete.textContent = "Delete";
      btnDelete.addEventListener("click", () => deleteCard(card.id));

      actionsEl.appendChild(btnEdit);
      actionsEl.appendChild(btnDelete);
    }

    async function saveCardEdits(cardBoxEl, card, newFrontRaw, newBackRaw) {
      const newFront = newFrontRaw.trim();
      const newBack = newBackRaw.trim();

      if (!token) {
        deckCardsStatus.className = "error";
        deckCardsStatus.textContent = "Login first.";
        return;
      }

      if (!newFront || !newBack) {
        deckCardsStatus.className = "error";
        deckCardsStatus.textContent = "Front and back are required.";
        return;
      }

      try {
        deckCardsStatus.className = "muted";
        deckCardsStatus.textContent = `Saving card ${card.id}...`;

        const res = await fetch(`/cards/${card.id}`, {
          method: "PATCH",
          headers: { "Content-Type": "application/json", ...authHeaders() },
          body: JSON.stringify({ front: newFront, back: newBack }),
        });

        if (!res.ok)
          throw new Error((await res.json()).detail || "Update card failed");

        const updated = await res.json(); // {id, front, back}

        // Update the local card object so view mode uses new text
        card.front = updated.front;
        card.back = updated.back;

        deckCardsStatus.className = "ok";
        deckCardsStatus.textContent = `Saved card ${card.id}.`;

        // Flip UI back to view mode (now showing updated values)
        exitEditMode(cardBoxEl, card);
      } catch (err) {
        deckCardsStatus.className = "error";
        deckCardsStatus.textContent = err.message;
      }
    }

    // CARD SRS (LEARN/REVIEW) SCRIPTS

    //Learn card references
    let currentNewCard = null;
    const btnLoadNew = document.getElementById("btnLoadNew");
    const newFront = document.getElementById("newFront");
    const newBack = document.getElementById("newBack");
    const newMeta = document.getElementById("newMeta"); 
    const btnRevealNewBack = document.getElementById("btnRevealNewBack");
    const btnLearnCurrent = document.getElementById("btnLearnCurrent");

    //Fetch new card
    btnLoadNew.addEventListener("click", async () => {
      const deckId = selectedDeckId();

      if (!token) {
        newMeta.className = "error mono";
        newMeta.textContent = "Login first.";
        return;
      }
      if (!deckId) {
        newMeta.className = "error mono";
        newMeta.textContent = "Select a deck first.";
        return;
      }

      newMeta.className = "muted mono";
      newMeta.textContent = "Loading next new card...";

      try {
        const res = await fetch(`/decks/${deckId}/cards/new`, {
          headers: authHeaders(),
        });

        if (!res.ok) throw new Error((await res.json()).detail || "Failed to load new card");

        const card = await res.json(); // {id, front, back}
        currentNewCard = card;

        // Populate UI (front only for now)
        newFront.querySelector("pre").textContent = card.front;

        // Keep back hidden for now (and clear any previous back)
        newBack.querySelector("pre").textContent = "";
        newBack.classList.add("hidden");
        btnLearnCurrent.classList.add("hidden");

        newMeta.className = "ok mono";
        newMeta.textContent = `Loaded NEW card #${card.id}`;
      } catch (err) {
        currentNewCard = null;

        newFront.querySelector("pre").textContent = "";
        newBack.querySelector("pre").textContent = "";
        newBack.classList.add("hidden");

        newMeta.className = "muted mono";
        newMeta.textContent = err.message; // e.g. "No new cards"
      }
    });

    //Reveal new card Back
    btnRevealNewBack.addEventListener("click", () => {
      if (!currentNewCard) {
        newMeta.className = "error mono";
        newMeta.textContent = "Load a new card first.";
        return;
      }

      // Show back text
      newBack.querySelector("pre").textContent = currentNewCard.back;
      newBack.classList.remove("hidden");

      // Show Learn button
      btnLearnCurrent.classList.remove("hidden");
    });

    //Learn card
    btnLearnCurrent.addEventListener("click", async () => {
      if (!currentNewCard) {
        newMeta.className = "error mono";
        newMeta.textContent = "No card loaded.";
        return;
      }

      const cardId = currentNewCard.id;

      newMeta.className = "muted mono";
      newMeta.textContent = `Learning card #${cardId}...`;

      try {
        const res = await fetch(`/cards/${cardId}/learn`, {
          method: "POST",
          headers: authHeaders(),
        });

        if (!res.ok)
          throw new Error((await res.json()).detail || "Learn card failed");

        // Reset UI to initial state
        currentNewCard = null;

        newFront.querySelector("pre").textContent = "";
        newBack.querySelector("pre").textContent = "";
        newBack.classList.add("hidden");
        btnLearnCurrent.classList.add("hidden");

        newMeta.className = "ok mono";
        newMeta.textContent = `Learned card with id "${cardId}"`;
      } catch (err) {
        newMeta.className = "error mono";
        newMeta.textContent = err.message;
      }
    });

    //Due card references
    let currentDueCard = null;
    const btnLoadDue = document.getElementById("btnLoadDue");
    const dueFront = document.getElementById("dueFront");
    const dueBack = document.getElementById("dueBack");
    const dueMeta = document.getElementById("dueMeta");
    const btnRevealDueBack = document.getElementById("btnRevealDueBack");
    const reviewRow = document.getElementById("reviewRow");
    const reviewButtons = document.querySelectorAll(".btnReview");

    //Fetch due card
    btnLoadDue.addEventListener("click", async () => {
      const deckId = selectedDeckId();

      if (!token) {
        dueMeta.className = "error mono";
        dueMeta.textContent = "Login first.";
        return;
      }
      if (!deckId) {
        dueMeta.className = "error mono";
        dueMeta.textContent = "Select a deck first.";
        return;
      }

      dueMeta.className = "muted mono";
      dueMeta.textContent = "Loading next due card...";

      // Reset visible state for this section
      currentDueCard = null;
      dueFront.querySelector("pre").textContent = "";
      dueBack.querySelector("pre").textContent = "";
      dueBack.classList.add("hidden"); // always start hidden
      reviewRow.classList.add("hidden");

      try {
        const res = await fetch(`/decks/${deckId}/cards/due`, {
          headers: authHeaders(),
        });

        if (!res.ok) {
          throw new Error((await res.json()).detail || "Failed to load due card");
        }

        const card = await res.json(); // {id, front, back}
        currentDueCard = card;

        // Preload both (but keep back hidden until reveal step)
        dueFront.querySelector("pre").textContent = card.front;
        dueBack.querySelector("pre").textContent = card.back;

        dueMeta.className = "ok mono";
        dueMeta.textContent = `Loaded DUE card #${card.id}`;
      } catch (err) {
        currentDueCard = null;

        dueFront.querySelector("pre").textContent = "";
        dueBack.querySelector("pre").textContent = "";
        dueBack.classList.add("hidden");

        dueMeta.className = "muted mono";
        dueMeta.textContent = err.message; // e.g. "No due cards"
      }
    });

    //Reveal due card back
    btnRevealDueBack.addEventListener("click", () => {
      if (!currentDueCard) {
        dueMeta.className = "error mono";
        dueMeta.textContent = "Load a due card first.";
        return;
      }

      dueBack.classList.remove("hidden");     // show back box
      reviewRow.classList.remove("hidden");   // show 0–5 buttons row
    });

    //Review due card
    reviewButtons.forEach((btn) => {
      btn.addEventListener("click", async () => {
        if (!currentDueCard) {
          dueMeta.className = "error mono";
          dueMeta.textContent = "Load a due card first.";
          return;
        }

        const cardId = currentDueCard.id;
        const quality = Number(btn.dataset.q);

        dueMeta.className = "muted mono";
        dueMeta.textContent = `Reviewing card #${cardId} (q=${quality})...`;

        try {
          const res = await fetch(`/cards/${cardId}/review`, {
            method: "POST",
            headers: { "Content-Type": "application/json", ...authHeaders() },
            body: JSON.stringify({ quality }),
          });

          if (!res.ok) {
            throw new Error((await res.json()).detail || "Review failed");
          }

          // Reset UI to initial state
          currentDueCard = null;

          dueFront.querySelector("pre").textContent = "";
          dueBack.querySelector("pre").textContent = "";
          dueBack.classList.add("hidden");
          reviewRow.classList.add("hidden");

          dueMeta.className = "ok mono";
          dueMeta.textContent = `Reviewed card with id "${cardId}" (Rating=${quality})`;
        } catch (err) {
          dueMeta.className = "error mono";
          dueMeta.textContent = err.message;
        }
      });
    });

    // Cleanup and misc.
    function clearCardsUI() {
      deckCards.innerHTML = "";
      deckCardsStatus.className = "muted";
      deckCardsStatus.textContent = "No cards displayed.";
      createCardStatus.className = "muted";
      createCardStatus.textContent = ""
    }

    function clearLearnUI() {
      currentNewCard = null;

      newFront.querySelector("pre").textContent = "";
      newBack.querySelector("pre").textContent = "";
      newBack.classList.add("hidden");

      btnLearnCurrent.classList.add("hidden");

      newMeta.className = "muted mono";
      newMeta.textContent = "No card loaded";
    }

    function clearReviewUI() {
      currentDueCard = null;

      dueFront.querySelector("pre").textContent = "";
      dueBack.querySelector("pre").textContent = "";
      dueBack.classList.add("hidden");

      reviewRow.classList.add("hidden");

      dueMeta.className = "muted mono";
      dueMeta.textContent = "No card loaded";
    }

    function clearDeckUI() {
      // Clear dropdown + selection
      deckSelect.innerHTML = "";
      currentDeckLabel.textContent = "None selected";

      // Reset deck status + new deck input
      deckStatus.className = "muted";
      deckStatus.textContent = "No decks loaded.";
      newDeckNameInput.value = "";

      // Clear dependent areas
      clearCardsUI();
      clearLearnUI();
      clearReviewUI();
}

 </script>
</body>
</html> 